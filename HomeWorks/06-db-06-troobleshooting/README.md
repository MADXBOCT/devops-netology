1

составим список текущих операций командой `db.currentOp()`
https://www.mongodb.com/docs/v6.0/reference/method/db.currentOp/ \

так же можно получить список операций всего инстанса
`
db.adminCommand(
   {
     currentOp: 1
   }
)
`
https://www.mongodb.com/docs/v6.0/reference/command/currentOp/ \

удалим зависшую операцию командой `db.killOp()` по id, полученному в результате выполнения предыдущей команды
https://www.mongodb.com/docs/v6.0/reference/method/db.killOp/

вариант решения - оптимизация индекса(ов) для ускорения обработки запросов

2

Так как Redis это in-memory database, то скорее всего закончилалсь память

3

В качестве решения можно предложить:
   1. Проверить стабильность сетевого подключения
   2. `during query` может значить что запрос слишком большой и сервер не успевает его принять за 30 секунд (настройка по-умолчанию), нужно увеличть net_read_timeout до 60 или больше 

4 \
Операционная система спасает себя от обрушения и убивает процессы которые заняли оперативную память.
Проблему можно решить 
 - добавив оперативной памяти, увеличить swap
 - более сложно: выставить значения для shared_buffers + temp_buffers + work_mem, которые ограничат postgres
 - Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. За это отвечает переменная `vm.overcommit_memory`, выставить значение 2 
 - проверить есть ли еще процессы на сервере, которые занимают много памяти (по условию задачи, мы просто могли забыть выключить mysql сервер из задания 3)